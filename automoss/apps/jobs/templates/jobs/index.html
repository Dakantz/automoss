{% extends "main.html" %}
{% load static %}

{% block "links" %}
<link href="{% static "css/dropZoneFile.css" %}" rel="stylesheet">
<link href="{% static "css/dropZone.css" %}" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/animatecss/3.5.2/animate.min.css" rel="stylesheet" crossorigin="anonymous">
{% endblock %}

{% block "scripts" %}
<script src="{% static "js/dropZoneFile.js" %}" defer></script>
<script src="{% static "js/dropZone.js" %}" defer></script>
<script src="{% static "lib/jszip.min.js" %}" defer></script>
<script src="{% static "js/jobSubmission.js" %}"></script>
{% endblock %}

{% block "main-content" %}


{% block "navigation" %}
<!-- Navigation -->
	<a class="link-dark ps-2" style="text-decoration: none;" href="#">
	Home 
	</a> 
		<svg class="m-1" xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 19">
		<path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
		</svg> 
	<a class="" style="text-decoration: none;" href="#">
	Jobs
	</a> 
{% endblock %}

<!-- Page Title -->
<h2 class="py-2 px-1 fw-bold">
	Submitted Jobs
</h2>

<!-- Content -->
<div class="container-fluid shadow-sm bg-white py-3 px-4 rounded-3">

<!-- Search/Create -->
<div class="row mb-3">
	<div class="col-lg-12">
		<div class="input-group px-1 pt-2 justify-content-between">
			<input class="form-control me-2 rounded" id="job-search" type="search" placeholder="Search..." aria-label="Search">
			<span class="input-group-btn">
				<button type="button" class="btn btn-primary text-light rounded-pill" data-bs-toggle="modal" data-bs-target="#create-job-modal">
					<svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" fill="currentColor" class="bi bi-plus" viewBox="4 2.5 13 13">
						<path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
					  </svg>
					Create Job</button>
			</span>
		</div>
	</div>
</div>

<!-- Table -->
<table id="job-table" class="table table-hover table-striped border rounded-3" style="background-color: white">

	<!-- Headings -->
	<thead class="table-dark">
		<tr>
			<th scope="col" style="width: 30%">Name</th>
			<th scope="col" style="width: 30%">Language</th>
			<th scope="col" style="width: 30%">Date Created</th>
			<th scope="col" style="width: 10%">Status</th>
		</tr>
	</thead>
	
	<!-- Jobs -->
	<tbody>
	</tbody>

</table>
<div id="no-jobs-message" class="container text-center" style="display: none">No jobs have been created yet!</div>

<!-- Modal -->
<div class="modal fade" id="create-job-modal" tabindex="-1" aria-hidden="true">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<form id="create-job-form">

				{% csrf_token %}

				<!-- Header -->
				<div class="modal-header bg-dark text-light">
					<h5 class="modal-title"><b>Create Job</b></h5>
					<button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close">
					</button>
				</div>

				<!-- Body -->
				<div class="modal-body">

					<!-- Drop Zone -->
					<div class="mb-3">
						<drop-zone id="job-drop-zone" filetypes="zip,tar,tar.gz,tar.xz,rar,tar.bz2"></drop-zone>
					</div>

					<!-- Name -->
					<div class="mb-3">
						<label for="job-name">Name:</label>
						<input class="form-control" id="job-name" type="text" name="job-name" autocomplete="off" data-lpignore="true" data-form-type="text">
					</div>

					<!-- Language -->
					<div class="mb-3">
						<label for="job-language">Language:</label>
						<select class="form-select" id="job-language" name="job-language" data-form-type="other">
							{% for language, info in SUPPORTED_LANGUAGES.items %}
								<option language-id={{language}}>{{info.0}} </option>
							{% endfor %}
						</select>
					</div>

					<!-- Max Matches Until Ignored -->
					<div class="mb-3">
						<label for="job-max-until-ignored">Max matches until ignored:</label>
						<input class="form-control" id="job-max-until-ignored" type="number" name="job-max-until-ignored" value="{{ DEFAULT_MOSS_SETTINGS.max_until_ignored }}">
					</div>

					<!-- Max Matches Displayed -->
					<div class="mb-3">
						<label for="job-max-displayed-matches">Max matches displayed:</label>
						<input class="form-control" id="job-max-displayed-matches" type="number" name="job-max-displayed-matches" value="{{DEFAULT_MOSS_SETTINGS.max_displayed_matches}}">
					</div>
				</div>

				<!-- Footer -->
				<div class="modal-footer d-flex justify-content-between p-2 bg-dark text-light">
					<label class="text-danger" id="job-error-message"></label>
					<div style="position: relative; max-height: 50px;">
						<button id="create-job-button" type="submit" class="btn btn-outline-primary border-2 rounded-pill" disabled>
							<svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" fill="currentColor" class="bi bi-plus" viewBox="4 2.5 13 13">
								<path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
							  </svg>
							Create</button>
					</div>
				</div>
			</form>
		</div>
	</div>
</div>
</div>



<script src="{% static "lib/uncompress/bz2.js" %}"></script>
<script src="{% static "lib/uncompress/pako.min.js" %}"></script>
<script src="{% static "lib/uncompress/uncompress.js" %}"></script>
<script type="text/javascript" src="{% static "lib/xz/archive.lib.min.js" %}"></script>
<script type="text/javascript" src="{% static "lib/xz/xz.js" %}"></script>

<script>
	
	let loadFormatsPromise = new Promise((resolve, reject) => {
		loadArchiveFormats(["zip", "tar", "rar"], () => {
			resolve();
		});
	});

	async function extractAll(file, password) {
		
		// Wait until formats have been loaded
		await loadFormatsPromise;

		// Wait until archived has been opened
		let openArchivePromise = new Promise((resolve, reject) => {
			archiveOpenFile(file, password, (archive) => {
				resolve(archive);
			});
		});
		let archive = await openArchivePromise;

		// Wait until all the files have been read
		let readPromises = []

		archive.entries.forEach(function(entry) {
			if(entry.is_file){
				readPromises.push(new Promise((resolve, reject)=>{
					entry.readData(function(entryData){
						resolve({name: entry.name, data: entryData});
					});
				}));
			}
			
		});
		return await Promise.all(readPromises);
	}

	function renameFile(originalFile, newName){
		return new File([originalFile], newName, {
			type: originalFile.type,
			lastModified: originalFile.lastModified,
		});
	}

	async function extractFiles(arch){
		let files = [];
		for (let file of await extractAll(arch)){
			files.push(new File([file.data], file.name))
		}
		return files;
	}

	window.extractFiles = extractFiles;

</script>

<script>
	window.addEventListener('DOMContentLoaded', function(){

	const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

	let languages = {{ SUPPORTED_LANGUAGES | js }};
	let statuses = {{ STATUSES | js }};

	let inQueueStatus = "{{ INQUEUE_STATUS }}";
	let processingStatus = "{{ PROCESSING_STATUS }}";
	let parsingStatus = "{{ PARSING_STATUS }}";
	let completedStatus = "{{ COMPLETED_STATUS }}";
	let failedStatus = "{{ FAILED_STATUS }}";

	class Job extends HTMLTableRowElement{
		constructor(obj) {
			super()
			Object.assign(this, obj)

			this.setAttribute('job_id', obj.job_id)
			this.setAttribute('status', obj.status)

			this.tableComment = document.createElement('td')
			this.tableComment.innerHTML = this.comment;
			
			this.tableLanguage = document.createElement('td')
			this.tableLanguage.innerHTML = languages[this.language][0];

			this.tableStartDate = document.createElement('td')
			this.tableStartDate.innerHTML = new Date(this.creation_date).toLocaleString();
			
			let tableStatusCell = document.createElement('td')
			this.tableStatus = document.createElement('span')
			tableStatusCell.append(this.tableStatus)
			
			this.append(this.tableComment)
			this.append(this.tableLanguage)
			this.append(this.tableStartDate)
			this.append(tableStatusCell)

			this.setStatus(this.status)
		}
		
		getText(node) {
			let text = '';
			if (node.nodeType === document.TEXT_NODE){
				text += node.nodeValue + ' ';
			}else{
				for (let child of node.childNodes){
					text += this.getText(child);
				}
			}
			return text;
		}

		contains(text){
			return this.getText(this).toLowerCase().includes(text.toLowerCase());
		}

		show(){
			this.style.display = "table-row";
		}
		hide(){
			this.style.display = "none";
		}

		setStatus(newStatus){
			this.tableStatus.innerHTML = statuses[newStatus]
			if(newStatus == completedStatus){
				this.tableComment.innerHTML = `<a href="/jobs/${this.job_id}/result/" style="text-decoration: none;">${this.comment}</a>`
			}

			this.tableStatus.className = '';
			
			let classes = ['badge', statusMapping[newStatus]];

			this.tableStatus.classList.add(...classes)
		}
	}
	customElements.define('job-row', Job, { extends: 'tr' });

	let statusMapping = {};
	statusMapping[inQueueStatus] = 'bg-warning';
	statusMapping[processingStatus] = 'bg-info';
	statusMapping[parsingStatus] = 'bg-dark';
	statusMapping[completedStatus] = 'bg-success';
	statusMapping[failedStatus] = 'bg-danger';


	
	// ----- Jobs Table -----

	let jobTable = document.getElementById('job-table')
	function addJob(job) {
		document.getElementById('no-jobs-message').style.display = 'none'
		jobTable.getElementsByTagName('tbody')[0].prepend(new Job(job))
	}

	let jobSearch = document.getElementById('job-search')
	jobSearch.oninput = function(){
		for (let child of jobTable.tBodies[0].children){
			if(child.contains(jobSearch.value)){
				child.show()
			}else{
				child.hide()
			}
		}
	}

	const terminalStates = [completedStatus, failedStatus];
	function isTerminalState(state){
		return terminalStates.includes(state)
	}

	let unfinishedJobs = [];
	let result = fetch("{% url "api:jobs:get_jobs" %}").then(async (response)=>{
		let json = await response.json()

		json.forEach(item => {
			addJob(item);
			if (!isTerminalState(item.status)){
				unfinishedJobs.push(item.job_id)
			}
		});
		if(json.length == 0){
			document.getElementById('no-jobs-message').style.display = 'block'
		}
	});

	setInterval(async function() {
		if(unfinishedJobs.length == 0) {
			return;
		}
		let result = await fetch(
			"{% url "api:jobs:get_statuses" %}?" + new URLSearchParams({job_ids: unfinishedJobs})
		)

		let json = await result.json();

		for (let key in json) {
			var value = json[key];

			document.querySelector(`tr[job_id="${key}"]`).setStatus(value)
			if(isTerminalState(value)){
				unfinishedJobs = unfinishedJobs.filter(item => item !== key)
			}
		}
		
	},{{ POLLING_TIME }});


	// ----- Create Job -----

	let createJobModalElement = document.getElementById('create-job-modal');
	let createJobModal = new bootstrap.Modal(createJobModalElement);
	let createJobForm = document.getElementById('create-job-form')

	let jobDropZone = document.getElementById('job-drop-zone')
	let jobName = document.getElementById('job-name');
	let jobLanguage = document.getElementById('job-language')
	let jobMaxMatchesUntilIgnored = document.getElementById('job-max-until-ignored');
	let jobMaxMatchesDisplayed = document.getElementById('job-max-displayed-matches');
	let jobErrorMessage = document.getElementById("job-error-message");
	let createJobButton = document.getElementById('create-job-button');

	let isDisplayingError = false;
	function displayError(message){
		if (isDisplayingError){
			return;
		}
		jobErrorMessage.textContent = message;
		createJobModalElement.classList.add("animated", "shake");
		isDisplayingError = true;

		setTimeout(function(){ 
			jobErrorMessage.textContent = "";
			createJobModalElement.classList.remove("animated", "shake");
			isDisplayingError = false;
		}, 3000);

		//$dialog.one('webkitAnimationEnd oanimationend msAnimationEnd animationend', function() {});
	}

	createJobForm.onsubmit = async (e) => {

		e.preventDefault();

		// Create a new form (and capture name, language, max matches until ignored and max matches displayed)
		let jobFormData = new FormData(createJobForm);
		let numStudents = 0;

		function appendDataToForm(name, data){
			jobFormData.append("{{ FILES_NAME }}", new Blob([data]), name);
			numStudents++;
		}

		// Capture file data separately and append to created form
		let language = jobLanguage.options[jobLanguage.selectedIndex].getAttribute('language-id');
		for (let dropZoneFile of jobDropZone.files){
			let archive = dropZoneFile.file;
			let files = await extractFiles(archive);
			if (await isSingleSubmission(files)){
				appendDataToForm(archive.name, await extractSingle(files, language));
			}else{
				await extractBatch(files, language, appendDataToForm);
			}
		}

		// Can't submit only 1 student
		if (numStudents <= 1){
			displayError("Please submit more than 1 students' files.");
			return;
		}

		// Submit a new job with the created form
		let result = await fetch("{% url "jobs:new" %}", {
			method: 'POST',
			body: jobFormData,
		});

		// Receive the result as a json object and add it to the jobs table
		let json = await result.json();
		addJob(json);
		unfinishedJobs.push(json['job_id']);

		// Hide and reset the form data and dropzone
		createJobModal.hide();
		createJobForm.reset();
		jobDropZone.reset();
	};

	jobDropZone.onFileAdded = async (jobDropZoneFile) => {

		function getExtension(name){
			return name.split('.').pop();
		}

		function getProgrammingLanguage(files){
			let d = {};
			for (let key in languages){
				d[key] = 0;
			}
			for (let file of files){
				let extension = getExtension(file.name);
				for (let key in languages){
					if(languages[key][2].includes(extension)){
						d[key] += 1;
					}
				}
			}
			let bestID = Object.entries(d).reduce((a, b) => a[1] > b[1] ? a : b)[0]
			return languages[bestID][0];
		}

		let archive = jobDropZoneFile.file;
		let files = await extractFiles(archive);

		// Type
		let single = await isSingleSubmission(files);
		if (!single){
			let tmp = [];
			for (let file of files){
				if (isArchive(file.name)){
					let tmpArchive = await extractFiles(file);
					for (let tmpFile of tmpArchive){
						tmp.push(tmpFile);
					}
				}
			}
			files = files.concat(tmp);
		}

		// Programming Language
		let language = getProgrammingLanguage(files);

		// Tags
		jobDropZoneFile.addTag(single ? "Single" : "Batch", single ? "var(--bs-info)" : "var(--bs-warning)");
		jobDropZoneFile.addTag(language, "var(--bs-secondary)");

		if (jobDropZone.files.length == 1) {
			jobName.value = jobName.value || archive.name.slice(0, archive.name.length - 4);
			jobLanguage.value = language;

			createJobButton.disabled = false;
		}
	};

	jobDropZone.onFileRemoved = () => {
		if (jobDropZone.files.length == 0) {
			jobName.value = "";
			jobLanguage.selectedIndex = 0;
			jobMaxMatchesUntilIgnored.value = {{ DEFAULT_MOSS_SETTINGS.max_until_ignored }};
			jobMaxMatchesDisplayed.value = {{ DEFAULT_MOSS_SETTINGS.max_displayed_matches }};

			createJobButton.disabled = true;
		}
	};

	jobDropZone.onFileRejected = (reason) => {
		displayError(reason);
	}

	})
</script>

{% endblock %}