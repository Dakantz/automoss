{% extends "main.html" %}
{% load static %}

{% block "main-content" %}


<h2 class="mb-3">Jobs</h2>

<!-- Search/Create -->
<div class="input-group mb-4">
	<input class="form-control me-2 rounded" type="search" placeholder="Search...">
	<span class="input-group-btn">
		<button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#create-job-modal">Create Job</button>
	</span>
</div>

<!-- Table -->
<table id="job-table" class="table table-striped border" style="background-color: white">

	<!-- Headings -->
	<thead>
		<tr>
			<th scope="col" style="width: 30%">Name</th>
			<th scope="col" style="width: 30%">Language</th>
			<th scope="col" style="width: 30%">Date Created</th>
			<th scope="col" style="width: 10%">Status</th>
		</tr>
	</thead>
	
	<!-- Jobs -->
	<tbody></tbody>

</table>
<div id="no-jobs-message" class="container text-center" style="display: none">No jobs have been created yet!</div>

<!-- Modal -->
<div class="modal fade" id="create-job-modal" tabindex="-1" aria-hidden="true">
	<div class="modal-dialog modal-dialog-centered">
		<div class="modal-content">
			<form id="create-job-form">

				{% csrf_token %}

				<!-- Header -->
				<div class="modal-header">
					<h5 class="modal-title">Create Job</h5>
					<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
				</div>

				<!-- Body -->
				<div class="modal-body">

					<!-- DropZone -->
					<link href="{% static "css/dropZoneFile.css" %}" rel="stylesheet">
					<link href="{% static "css/dropZone.css" %}" rel="stylesheet">
					<div class="mb-3">
						<drop-zone id="job-drop-zone" filetypes="['zip', 'tar', 'rar']"></drop-zone>
					</div>
					<script src="{% static "js/dropZoneFile.js" %}"></script>
					<script src="{% static "js/dropZone.js" %}"></script>

					<!-- Name -->
					<div class="mb-3">
						<label for="job-name">Name:</label>
						<input class="form-control" id="job-name" type="text" name="job-name" autocomplete="off" data-lpignore="true" data-form-type="text">
					</div>

					<!-- Language -->
					<div class="mb-3">
						<label for="job-language">Language:</label>
						<select class="form-select" id="job-language" name="job-language" data-form-type="other">
							{% for language, info in SUPPORTED_LANGUAGES.items %}
								<option language-id={{language}}>{{info.0}} </option>
							{% endfor %}
						</select>
					</div>

					<!-- Max Matches Until Ignored -->
					<div class="mb-3">
						<label for="job-max-until-ignored">Max matches until ignored:</label>
						<input class="form-control" id="job-max-until-ignored" type="number" name="job-max-until-ignored" value="{{ DEFAULT_MOSS_SETTINGS.max_until_ignored }}">
					</div>

					<!-- Max Matches Displayed -->
					<div class="mb-3">
						<label for="job-max-displayed-matches">Max matches displayed:</label>
						<input class="form-control" id="job-max-displayed-matches" type="number" name="job-max-displayed-matches" value="{{DEFAULT_MOSS_SETTINGS.max_displayed_matches}}">
					</div>
				</div>

				<!-- Footer -->
				<div class="modal-footer">
					<div style="position: relative; min-height: 40px;">
						<button id="create-job-button" type="submit" class="btn btn-primary" disabled>Create</button>
					</div>
				</div>
			</form>
		</div>
	</div>
</div>


<script src="{% static "lib/jszip.min.js" %}"></script>
{% comment %} <script src="{% static "lib/uncompress/uncompress.js" %}"></script> {% endcomment %}
<script src="{% static "js/job.js" %}"></script>
<script src="{% static "js/jobSubmission.js" %}"></script>

<script>
	const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

	const languages = {{ SUPPORTED_LANGUAGES | js }};
	const statuses = {{ STATUSES | js }};

	const completedStatus = "{{ COMPLETED_STATUS }}";
	const processingStatus = "{{ PROCESSING_STATUS }}";
	const uploadingStatus = "{{ UPLOADING_STATUS }}";
	const failedStatus = "{{ FAILED_STATUS }}";

	
	// Jobs Table

	let jobTable = document.getElementById('job-table')
	function addJob(job) {
		document.getElementById('no-jobs-message').style.display = 'none'
		jobTable.getElementsByTagName('tbody')[0].prepend(new Job(job))
	}

	const terminalStates = [completedStatus, failedStatus];
	function isTerminalState(state){
		return terminalStates.includes(state)
	}

	let unfinishedJobs = [];
	let result = fetch("{% url "api:jobs:get_jobs" %}", {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			'X-CSRFToken': csrftoken
		}
	}).then(async (response)=>{
		let json = await response.json()

		json.forEach(item => {
			addJob(item);
			if (!isTerminalState(item.status)){
				unfinishedJobs.push(item.job_id)
			}
		});
		if(json.length == 0){
			document.getElementById('no-jobs-message').style.display = 'block'
		}
	});

	setInterval(async function() {
		if(unfinishedJobs.length == 0) {
			return;
		}
		let result = await fetch("{% url "api:jobs:get_statuses" %}", {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'X-CSRFToken': csrftoken
			},
			body: JSON.stringify({
				'job_ids': unfinishedJobs
			})
		})

		let json = await result.json();

		for (let key in json) {
			var value = json[key];

			document.querySelector(`tr[job_id="${key}"]`).setStatus(value)
			if(isTerminalState(value)){
				unfinishedJobs = unfinishedJobs.filter(item => item !== key)
			}
		}
		
	},{{ POLLING_TIME }});


	// Create Job

	let createJobModal = new bootstrap.Modal(document.getElementById('create-job-modal'));
	let createJobForm = document.getElementById('create-job-form')

	let jobDropZone = document.getElementById('job-drop-zone')
	let jobName = document.getElementById('job-name');
	let jobLanguage = document.getElementById('job-language')
	let jobMaxMatchesUntilIgnored = document.getElementById('job-max-until-ignored');
	let jobMaxMatchesDisplayed = document.getElementById('job-max-displayed-matches');
	let createJobButton = document.getElementById('create-job-button');

	function getExtension(name){
		return name.split('.').pop();
	}

	{% comment %} let loadFormatsPromise = new Promise((resolve, reject) => {
		loadArchiveFormats(["zip", "tar", "rar"], () => {
			resolve();
		});
	}); {% endcomment %}

	{% comment %} async function extractAndReadAll(file, password, onRead) {
		
		// Wait until formats have been loaded
		await loadFormatsPromise;

		// Wait until archived has been opened
		let openArchivePromise = new Promise((resolve, reject) => {
			archiveOpenFile(file, password, (archive) => {
				resolve(archive);
			});
		});
		let archive = await openArchivePromise;

		// Wait until all the files have been read
		let readPromises = []
		readPromises.push(Promise.all(archive.entries.map(async (entry) => {
			return new Promise((resolve, reject)=>{
				entry.readData(function(entryData){
					onRead(entry, entryData);
					resolve();
				});
			});
		})));
		await Promise.all(readPromises);
	} {% endcomment %}

	createJobForm.onsubmit = async (e) => {

		e.preventDefault();

		// Create a new form (and capture name, language, max matches until ignored and max matches displayed)
		let jobFormData = new FormData(createJobForm);

		function appendDataToForm(name, data){
			jobFormData.append("{{ FILES_NAME }}", new Blob([data]), name);
		}

		// Capture file data separately and append to created form
		let language = jobLanguage.options[jobLanguage.selectedIndex].getAttribute('language-id');
		for (let dropZoneFile of jobDropZone.files){
			let archive = dropZoneFile.file;
			let files = await getArchiveFiles(archive);
			if (await isSingleSubmission(files, language)){
				appendDataToForm(archive.name, await extractSingle(files, language));
			}else{
				await extractBatch(files, language, appendDataToForm);
			}
		}

		// Submit a new job with the created form
		let result = await fetch("{% url "jobs:new" %}", {
			method: 'POST',
			body: jobFormData,
		});

		// Receive the result as a json object and add it to the jobs table
		let json = await result.json();
		addJob(json);
		unfinishedJobs.push(json['job_id']);

		// Hide and reset the form data and dropzone
		createJobModal.hide();
		createJobForm.reset();
		jobDropZone.reset();
	};

	jobDropZone.onFileAdded = () => {
		if (jobDropZone.files.length == 1) {
			zipFile = jobDropZone.files[0].file;

			// Update form name
			jobName.value = jobName.value || zipFile.name.slice(0, zipFile.name.length - 4);

			// Update form programming language
			JSZip.loadAsync(zipFile).then((zip)=>{
				let d = {};
				for (let key in languages){
					d[key] = 0;
				}
				zip.forEach(function (relativePath, file) {
					let extension = getExtension(file.name);
					for (let key in languages){
						if(languages[key][2].includes(extension)){
							d[key] += 1;
						}
					}
				});
				let bestID = Object.entries(d).reduce((a, b) => a[1] > b[1] ? a : b)[0]
				jobLanguage.value = languages[bestID][0];
			});

			createJobButton.disabled = false;
		}
	};

	jobDropZone.onFileRemoved = () => {
		if (jobDropZone.files.length == 0) {
			jobName.value = "";
			jobLanguage.selectedIndex = 0;
			jobMaxMatchesUntilIgnored.value = {{ DEFAULT_MOSS_SETTINGS.max_until_ignored }};
			jobMaxMatchesDisplayed.value = {{ DEFAULT_MOSS_SETTINGS.max_displayed_matches }};

			createJobButton.disabled = true;
		}
	};



	// Job Stitching

	

</script>

{% endblock %}